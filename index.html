<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mindfulness | box breathing</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #1a1a1a;
            overflow: hidden;
        }
        #canvas {
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.2));
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            position: absolute;
        }
        button {
            position: absolute;
            padding: 12px 24px;
            font-size: 5vmin;
            font-weight: 600;
            cursor: pointer;
            background-color: rgba(26, 26, 26, 0.98);
            color: #e0e0e0;
            border: 3px solid #777;
            border-radius: 10px;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, filter 0.3s ease, box-shadow 0.3s ease, transform 0.1s ease;
            text-transform: lowercase;
            z-index: 10;
            white-space: nowrap;
        }
        #startStop.blue {
            color: #00bfff;
            background-color: rgba(119, 119, 119, 0.2);
            border-color: #00bfff;
            filter: drop-shadow(0 0 5px rgba(0, 191, 255, 0.3));
            box-shadow: 0 0 5px rgba(0, 191, 255, 0.3);
        }
        #cancelButton {
            font-size: 4vmin;
            padding: 8px 16px;
            z-index: 10;
            display: none;
        }
        button:active {
            transform: scale(0.95);
        }
        #button-tracer-canvas {
            position: absolute;
            border-radius: 10px;
            pointer-events: none;
            z-index: 9;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button id="startStop"><span id="button-text">tap to start</span></button>
    <button id="cancelButton">cancel</button>
    <canvas id="button-tracer-canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const buttonTracerCanvas = document.getElementById('button-tracer-canvas');
        const buttonTracerCtx = buttonTracerCanvas.getContext('2d');
        const startStop = document.getElementById('startStop');
        const cancelButton = document.getElementById('cancelButton');
        const buttonText = document.getElementById('button-text');
        let isRunning = false;
        let isCounting = false;
        let interval;
        let initialPulseInterval;
        let countdownInterval;
        let buttonTracerInterval;
        let canvasSize, scale, offsetX, offsetY, buttonWidth, buttonHeight;

        function resizeCanvas() {
            canvasSize = Math.min(window.innerWidth, window.innerHeight - 150) * 0.8;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            scale = canvasSize / 360;
            offsetX = (window.innerWidth - canvasSize) / 2;
            offsetY = (window.innerHeight - canvasSize - 60) / 2;
            canvas.style.left = `${offsetX}px`;
            canvas.style.top = `${offsetY}px`;
            startStop.style.left = `${offsetX + canvasSize / 2}px`;
            startStop.style.top = `${offsetY + canvasSize / 2}px`;
            startStop.style.transform = 'translate(-50%, -50%)';
            cancelButton.style.left = `${offsetX + canvasSize / 2}px`;
            cancelButton.style.top = `${offsetY + canvasSize + 20}px`;
            cancelButton.style.transform = 'translate(-50%, 0)';
            if (!buttonWidth || !buttonHeight) {
                buttonText.textContent = 'tap to start';
                const rect = startStop.getBoundingClientRect();
                buttonWidth = rect.width;
                buttonHeight = rect.height;
                startStop.style.width = `${buttonWidth}px`;
                startStop.style.height = `${buttonHeight}px`;
                buttonTracerCanvas.width = buttonWidth + 6;
                buttonTracerCanvas.height = buttonHeight + 6;
                buttonTracerCanvas.style.left = `${offsetX + canvasSize / 2 - (buttonWidth + 6) / 2}px`;
                buttonTracerCanvas.style.top = `${offsetY + canvasSize / 2 - (buttonHeight + 6) / 2}px`;
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const phases = [
            { text: 'inhale', start: { x: 40, y: 320 }, end: { x: 40, y: 40 } },
            { text: 'hold', start: { x: 40, y: 40 }, end: { x: 320, y: 40 } },
            { text: 'exhale', start: { x: 320, y: 40 }, end: { x: 320, y: 320 } },
            { text: 'hold', start: { x: 320, y: 320 }, end: { x: 40, y: 320 } }
        ];

        const corners = [
            { x: 40, y: 320, pulseTime: null },
            { x: 40, y: 40, pulseTime: null },
            { x: 320, y: 40, pulseTime: null },
            { x: 320, y: 320, pulseTime: null }
        ];

        function scaleCoord(coord) {
            return coord * scale;
        }

        function drawCorners(phaseIndex, progress) {
            const now = Date.now();
            corners.forEach((corner, index) => {
                let pulse = 0;
                if (index === 0 && !isRunning && !isCounting && initialPulseInterval) {
                    const elapsed = (now - corner.pulseTime) / 1000;
                    const seconds = elapsed % 4;
                    pulse = Math.max(0, Math.sin(Math.PI * (seconds % 1)) ** 2);
                }
                if (corner.pulseTime && now - corner.pulseTime < 1000) {
                    const elapsed = (now - corner.pulseTime) / 1000;
                    pulse = Math.max(0, Math.sin(Math.PI * elapsed) ** 2);
                }
                ctx.beginPath();
                ctx.arc(scaleCoord(corner.x), scaleCoord(corner.y), 3 * scale * (1 + 0.5 * pulse), 0, 2 * Math.PI);
                ctx.fillStyle = '#00bfff';
                ctx.filter = `blur(${2 * scale}px) brightness(${1 + pulse})`;
                ctx.fill();
                ctx.filter = 'none';
            });
        }

        function drawBox(phaseIndex, progress) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCorners(phaseIndex, progress);
            ctx.lineWidth = 5 * scale;
            ctx.strokeStyle = '#00bfff';
            ctx.lineCap = 'butt';
            ctx.lineJoin = 'miter';
            ctx.filter = 'drop-shadow(0 0 10px rgba(255, 255, 255, 0.4))';
            ctx.shadowBlur = 10 * scale;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.4)';

            ctx.beginPath();
            ctx.moveTo(scaleCoord(40), scaleCoord(320));
            let tracerX, tracerY;
            if (phaseIndex === 0) {
                tracerY = 320 - (320 - 40) * progress;
                ctx.lineTo(scaleCoord(40), scaleCoord(tracerY));
                tracerX = 40;
            } else if (phaseIndex >= 1) {
                ctx.lineTo(scaleCoord(40), scaleCoord(40));
                if (phaseIndex === 1) {
                    tracerX = 40 + (320 - 40) * progress;
                    ctx.lineTo(scaleCoord(tracerX), scaleCoord(40));
                    tracerY = 40;
                } else if (phaseIndex >= 2) {
                    ctx.lineTo(scaleCoord(320), scaleCoord(40));
                    if (phaseIndex === 2) {
                        tracerY = 40 + (320 - 40) * progress;
                        ctx.lineTo(scaleCoord(320), scaleCoord(tracerY));
                        tracerX = 320;
                    } else if (phaseIndex >= 3) {
                        ctx.lineTo(scaleCoord(320), scaleCoord(320));
                        if (phaseIndex === 3) {
                            tracerX = 320 - (320 - 40) * progress;
                            ctx.lineTo(scaleCoord(tracerX), scaleCoord(320));
                            tracerY = 320;
                        }
                        if (phaseIndex === 3 && progress >= 1) {
                            ctx.lineTo(scaleCoord(40), scaleCoord(320));
                        }
                    }
                }
            }
            ctx.stroke();

            if (phaseIndex >= 1) {
                ctx.beginPath();
                ctx.moveTo(scaleCoord(40), scaleCoord(40));
                ctx.lineTo(scaleCoord(40), scaleCoord(40));
                ctx.stroke();
            }
            if (phaseIndex >= 2) {
                ctx.beginPath();
                ctx.moveTo(scaleCoord(320), scaleCoord(40));
                ctx.lineTo(scaleCoord(320), scaleCoord(40));
                ctx.stroke();
            }
            if (phaseIndex >= 3) {
                ctx.beginPath();
                ctx.moveTo(scaleCoord(320), scaleCoord(320));
                ctx.lineTo(scaleCoord(320), scaleCoord(320));
                ctx.stroke();
            }
            if (phaseIndex === 3 && progress >= 1 || phaseIndex < 3) {
                ctx.beginPath();
                ctx.moveTo(scaleCoord(40), scaleCoord(320));
                ctx.lineTo(scaleCoord(40), scaleCoord(320));
                ctx.stroke();
            }

            ctx.filter = 'none';
            ctx.shadowBlur = 0;
            return { tracerX, tracerY };
        }

        function drawTracer(phaseIndex, progress, pulse) {
            const phase = phases[phaseIndex];
            const { tracerX, tracerY } = drawBox(phaseIndex, progress);

            let x = tracerX || phase.start.x + (phase.end.x - phase.start.x) * progress;
            let y = tracerY || phase.start.y + (phase.end.y - phase.start.y) * progress;

            corners.forEach((corner, index) => {
                const dist = Math.sqrt((x - corner.x) ** 2 + (y - corner.y) ** 2);
                if (dist < 10) {
                    x = corner.x;
                    y = corner.y;
                    if (!corner.pulseTime) {
                        corner.pulseTime = Date.now();
                        setTimeout(() => { corner.pulseTime = null; }, 1000);
                    }
                }
            });

            for (let i = 1; i <= 3; i++) {
                const trailProgress = Math.max(0, progress - i * 0.05);
                const trailX = phase.start.x + (phase.end.x - phase.start.x) * trailProgress;
                const trailY = phase.start.y + (phase.end.y - phase.start.y) * trailProgress;
                ctx.beginPath();
                ctx.arc(scaleCoord(trailX), scaleCoord(trailY), 2 * scale * (1 - i * 0.3), 0, 2 * Math.PI);
                ctx.fillStyle = `rgba(0, 191, 255, ${1 - i * 0.3})`;
                ctx.fill();
            }

            ctx.beginPath();
            ctx.arc(scaleCoord(x), scaleCoord(y), 4 * scale * (1 + 0.6 * pulse), 0, 2 * Math.PI);
            ctx.fillStyle = '#00bfff';
            ctx.filter = `blur(${5 * scale}px) brightness(${1 + 1.2 * pulse})`;
            ctx.fill();
            ctx.filter = 'none';

            buttonText.textContent = phase.text;
        }

        function drawInitialPulse() {
            corners[0].pulseTime = Date.now();
            initialPulseInterval = setInterval(() => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawCorners(0, 0);
                ctx.beginPath();
                ctx.arc(scaleCoord(40), scaleCoord(320), 4 * scale, 0, 2 * Math.PI);
                ctx.fillStyle = '#00bfff';
                const elapsed = (Date.now() - corners[0].pulseTime) / 1000;
                const seconds = elapsed % 4;
                const pulse = Math.max(0, Math.sin(Math.PI * (seconds % 1)) ** 2);
                ctx.filter = `blur(${5 * scale}px) brightness(${1 + 1.2 * pulse})`;
                ctx.fill();
                ctx.filter = 'none';
            }, 50);
        }

        function updateBreathing(phaseIndex, seconds, progress) {
            const pulse = Math.max(0, Math.sin(Math.PI * (seconds % 1)) ** 2);
            drawTracer(phaseIndex, progress, pulse);
        }

        function runCycle() {
            let phaseIndex = 0;
            let seconds = 0;
            let startTime = Date.now();

            startStop.classList.add('blue');
            updateBreathing(phaseIndex, seconds, 0);

            interval = setInterval(() => {
                const elapsed = (Date.now() - startTime) / 1000;
                seconds = elapsed % 4;
                const progress = seconds / 4;

                if (elapsed >= 4) {
                    startTime = Date.now();
                    phaseIndex = (phaseIndex + 1) % phases.length;
                }

                updateBreathing(phaseIndex, seconds, progress);
            }, 50);
        }

        function drawButtonTracer(progress) {
            buttonTracerCtx.clearRect(0, 0, buttonTracerCanvas.width, buttonTracerCanvas.height);
            const w = buttonWidth + 6;
            const h = buttonHeight + 6;
            const r = 10;
            const perimeter = 2 * (w + h - 4 * r) + 2 * Math.PI * r;
            let distance = progress * perimeter;
            let x, y;

            if (distance < w - r) {
                x = 3 + distance;
                y = 3;
            } else if (distance < w - r + h - r) {
                x = w - 3;
                y = 3 + (distance - (w - r));
            } else if (distance < w - r + h - r + w - r) {
                x = w - 3 - (distance - (w - r + h - r));
                y = h - 3;
            } else if (distance < w - r + h - r + w - r + h - r) {
                x = 3;
                y = h - 3 - (distance - (w - r + h - r + w - r));
            } else {
                const arcLength = distance - (w - r + h - r + w - r + h - r);
                const angle = arcLength / r;
                const corner = Math.floor((distance - (w - r + h - r + w - r + h - r)) / (Math.PI * r / 2));
                if (corner === 0) {
                    x = 3 + r - r * Math.cos(angle);
                    y = 3 + r - r * Math.sin(angle);
                } else if (corner === 1) {
                    x = w - 3 - r + r * Math.cos(angle - Math.PI / 2);
                    y = 3 + r - r * Math.sin(angle - Math.PI / 2);
                } else if (corner === 2) {
                    x = w - 3 - r + r * Math.cos(angle - Math.PI);
                    y = h - 3 - r + r * Math.sin(angle - Math.PI);
                } else {
                    x = 3 + r - r * Math.cos(angle - 3 * Math.PI / 2);
                    y = h - 3 - r + r * Math.sin(angle - 3 * Math.PI / 2);
                }
            }

            buttonTracerCtx.beginPath();
            buttonTracerCtx.arc(x, y, 1.5, 0, 2 * Math.PI);
            buttonTracerCtx.fillStyle = 'rgba(0, 191, 255, 0.4)';
            buttonTracerCtx.filter = 'blur(6px) brightness(1.03)';
            buttonTracerCtx.fill();
            buttonTracerCtx.filter = 'none';
        }

        function startButtonTracer() {
            let startTime = Date.now();
            buttonTracerInterval = setInterval(() => {
                const elapsed = (Date.now() - startTime) / 1000;
                const progress = elapsed % 1;
                drawButtonTracer(progress);
            }, 16);
        }

        function stopButtonTracer() {
            clearInterval(buttonTracerInterval);
            buttonTracerCtx.clearRect(0, 0, buttonTracerCanvas.width, buttonTracerCanvas.height);
        }

        function startCountdown(callback) {
            let count = 5;
            isCounting = true;
            startStop.classList.add('blue');
            cancelButton.style.display = 'block';
            startButtonTracer();
            buttonText.textContent = count;
            countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    buttonText.textContent = count;
                } else {
                    clearInterval(countdownInterval);
                    stopButtonTracer();
                    cancelButton.style.display = 'none';
                    buttonText.textContent = phases[0].text;
                    callback();
                    isCounting = false;
                }
            }, 1000);
        }

        function cancelCountdown() {
            clearInterval(countdownInterval);
            clearInterval(buttonTracerInterval);
            stopButtonTracer();
            buttonText.textContent = 'tap to start';
            startStop.classList.remove('blue');
            cancelButton.style.display = 'none';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawInitialPulse();
            isCounting = false;
            isRunning = false;
        }

        function handleStartStop() {
            if (isRunning) {
                clearInterval(interval);
                clearInterval(initialPulseInterval);
                cancelButton.style.display = 'none';
                buttonText.textContent = 'tap to start';
                startStop.classList.remove('blue');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawInitialPulse();
                isRunning = false;
            } else if (!isCounting) {
                clearInterval(initialPulseInterval);
                corners[0].pulseTime = Date.now();
                startCountdown(() => {
                    runCycle();
                    isRunning = true;
                });
            }
        }

        startStop.addEventListener('click', handleStartStop);
        startStop.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleStartStop();
        });

        cancelButton.addEventListener('click', cancelCountdown);
        cancelButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            cancelCountdown();
        });

        cancelButton.style.display = 'none';
        drawInitialPulse();
    </script>
</body>
</html>